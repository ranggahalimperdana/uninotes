/* 
 * SUPABASE CONFIGURATION & SERVICE LAYER
 * superadmin@uninotes.com // passwordSangatRahasia123
 * Setup Instructions:
 * 1. Install Supabase client: npm install @supabase/supabase-js
 * 2. Create Supabase project at https://supabase.com
 * 3. Get your project URL and anon key from project settings
 * 4. Replace SUPABASE_URL and SUPABASE_ANON_KEY below
 */

// import { createClient } from '@supabase/supabase-js';

// const SUPABASE_URL = 'YOUR_SUPABASE_URL'; // e.g., https://xxxxx.supabase.co
// const SUPABASE_ANON_KEY = 'YOUR_SUPABASE_ANON_KEY';

// export const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/*
 * DATABASE SCHEMA
 * 
 * Run these SQL commands in Supabase SQL Editor:
 * 
 * -- 1. Create users table (extends Supabase auth.users)
 * CREATE TABLE public.profiles (
 *   id UUID REFERENCES auth.users(id) PRIMARY KEY,
 *   email TEXT UNIQUE NOT NULL,
 *   full_name TEXT NOT NULL,
 *   faculty TEXT NOT NULL,
 *   prodi TEXT NOT NULL,
 *   role TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('user', 'admin')),
 *   profile_picture TEXT,
 *   created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 *   updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
 * );
 * 
 * -- 2. Create posts table (catatan/tugas)
 * CREATE TABLE public.posts (
 *   id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
 *   title TEXT NOT NULL,
 *   description TEXT,
 *   course_code TEXT NOT NULL,
 *   course_title TEXT NOT NULL,
 *   faculty TEXT NOT NULL,
 *   prodi TEXT NOT NULL,
 *   semester INTEGER,
 *   file_url TEXT NOT NULL,
 *   file_type TEXT NOT NULL,
 *   file_size INTEGER,
 *   uploaded_by UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
 *   author_name TEXT NOT NULL,
 *   author_email TEXT NOT NULL,
 *   views INTEGER DEFAULT 0,
 *   downloads INTEGER DEFAULT 0,
 *   created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 *   updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
 * );
 * 
 * -- 3. Create admin_logs table (track admin actions)
 * CREATE TABLE public.admin_logs (
 *   id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
 *   admin_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
 *   admin_email TEXT NOT NULL,
 *   action_type TEXT NOT NULL, -- 'delete_post', 'promote_user'
 *   target_id UUID, -- post_id or user_id
 *   target_email TEXT,
 *   details JSONB,
 *   created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
 * );
 * 
 * -- 4. Enable Row Level Security (RLS)
 * ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
 * ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
 * ALTER TABLE public.admin_logs ENABLE ROW LEVEL SECURITY;
 * 
 * -- 5. RLS Policies for profiles
 * -- Users can read all profiles
 * CREATE POLICY "Profiles are viewable by all users" ON public.profiles
 *   FOR SELECT USING (true);
 * 
 * -- Users can update their own profile
 * CREATE POLICY "Users can update own profile" ON public.profiles
 *   FOR UPDATE USING (auth.uid() = id);
 * 
 * -- Admins can update any profile (for role promotion)
 * CREATE POLICY "Admins can update any profile" ON public.profiles
 *   FOR UPDATE USING (
 *     EXISTS (
 *       SELECT 1 FROM public.profiles
 *       WHERE id = auth.uid() AND role = 'admin'
 *     )
 *   );
 * 
 * -- 6. RLS Policies for posts
 * -- Anyone can read posts
 * CREATE POLICY "Posts are viewable by all" ON public.posts
 *   FOR SELECT USING (true);
 * 
 * -- Only users (non-admins) can create posts
 * CREATE POLICY "Users can create posts" ON public.posts
 *   FOR INSERT WITH CHECK (
 *     EXISTS (
 *       SELECT 1 FROM public.profiles
 *       WHERE id = auth.uid() AND role = 'user'
 *     )
 *   );
 * 
 * -- Users can update their own posts
 * CREATE POLICY "Users can update own posts" ON public.posts
 *   FOR UPDATE USING (auth.uid() = uploaded_by);
 * 
 * -- Users can delete their own posts
 * CREATE POLICY "Users can delete own posts" ON public.posts
 *   FOR DELETE USING (auth.uid() = uploaded_by);
 * 
 * -- Admins can delete any post
 * CREATE POLICY "Admins can delete any post" ON public.posts
 *   FOR DELETE USING (
 *     EXISTS (
 *       SELECT 1 FROM public.profiles
 *       WHERE id = auth.uid() AND role = 'admin'
 *     )
 *   );
 * 
 * -- 7. RLS Policies for admin_logs
 * -- Only admins can read logs
 * CREATE POLICY "Admins can read logs" ON public.admin_logs
 *   FOR SELECT USING (
 *     EXISTS (
 *       SELECT 1 FROM public.profiles
 *       WHERE id = auth.uid() AND role = 'admin'
 *     )
 *   );
 * 
 * -- Only admins can create logs
 * CREATE POLICY "Admins can create logs" ON public.admin_logs
 *   FOR INSERT WITH CHECK (
 *     EXISTS (
 *       SELECT 1 FROM public.profiles
 *       WHERE id = auth.uid() AND role = 'admin'
 *     )
 *   );
 * 
 * -- 8. Create indexes for better performance
 * CREATE INDEX idx_posts_course_code ON public.posts(course_code);
 * CREATE INDEX idx_posts_faculty ON public.posts(faculty);
 * CREATE INDEX idx_posts_uploaded_by ON public.posts(uploaded_by);
 * CREATE INDEX idx_posts_created_at ON public.posts(created_at DESC);
 * CREATE INDEX idx_profiles_role ON public.profiles(role);
 * CREATE INDEX idx_profiles_email ON public.profiles(email);
 * 
 * -- 9. Create trigger for updated_at
 * CREATE OR REPLACE FUNCTION update_updated_at_column()
 * RETURNS TRIGGER AS $$
 * BEGIN
 *   NEW.updated_at = NOW();
 *   RETURN NEW;
 * END;
 * $$ LANGUAGE plpgsql;
 * 
 * CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles
 *   FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
 * 
 * CREATE TRIGGER update_posts_updated_at BEFORE UPDATE ON public.posts
 *   FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
 */

// ============================================================
// TYPE DEFINITIONS
// ============================================================

export interface Profile {
  id: string;
  email: string;
  full_name: string;
  faculty: string;
  prodi: string;
  role: 'user' | 'admin';
  profile_picture?: string;
  created_at: string;
  updated_at: string;
}

export interface Post {
  id: string;
  title: string;
  description?: string;
  course_code: string;
  course_title: string;
  faculty: string;
  prodi: string;
  semester?: number;
  file_url: string;
  file_type: string;
  file_size?: number;
  uploaded_by: string; // UUID
  author_name: string;
  author_email: string;
  views: number;
  downloads: number;
  created_at: string;
  updated_at: string;
}

export interface AdminLog {
  id: string;
  admin_id: string;
  admin_email: string;
  action_type: 'delete_post' | 'promote_user';
  target_id?: string;
  target_email?: string;
  details?: Record<string, any>;
  created_at: string;
}

// ============================================================
// AUTH SERVICES
// ============================================================

export const authService = {
  /**
   * Sign up a new user
   * Uncomment when Supabase is connected
   */
  signUp: async (email: string, password: string, userData: {
    fullName: string;
    faculty: string;
    prodi: string;
  }) => {
    // const { data, error } = await supabase.auth.signUp({
    //   email,
    //   password,
    //   options: {
    //     data: {
    //       full_name: userData.fullName,
    //       faculty: userData.faculty,
    //       prodi: userData.prodi,
    //     }
    //   }
    // });
    
    // if (error) throw error;
    
    // // Create profile
    // const { error: profileError } = await supabase
    //   .from('profiles')
    //   .insert({
    //     id: data.user!.id,
    //     email: email,
    //     full_name: userData.fullName,
    //     faculty: userData.faculty,
    //     prodi: userData.prodi,
    //     role: 'user'
    //   });
    
    // if (profileError) throw profileError;
    // return data;
    
    throw new Error('Supabase not connected. Please configure Supabase connection.');
  },

  /**
   * Sign in user
   * Returns user data with role
   */
  signIn: async (email: string, password: string): Promise<Profile> => {
    // const { data, error } = await supabase.auth.signInWithPassword({
    //   email,
    //   password,
    // });
    
    // if (error) throw error;
    
    // // Get user profile with role
    // const { data: profile, error: profileError } = await supabase
    //   .from('profiles')
    //   .select('*')
    //   .eq('id', data.user.id)
    //   .single();
    
    // if (profileError) throw profileError;
    // return profile as Profile;
    
    throw new Error('Supabase not connected. Please configure Supabase connection.');
  },

  /**
   * Sign out user
   */
  signOut: async () => {
    // const { error } = await supabase.auth.signOut();
    // if (error) throw error;
    
    throw new Error('Supabase not connected. Please configure Supabase connection.');
  },

  /**
   * Get current session
   */
  getSession: async () => {
    // const { data, error } = await supabase.auth.getSession();
    // if (error) throw error;
    // return data.session;
    
    return null;
  },

  /**
   * Get current user profile with role
   */
  getCurrentProfile: async (): Promise<Profile | null> => {
    // const { data: { user } } = await supabase.auth.getUser();
    // if (!user) return null;
    
    // const { data, error } = await supabase
    //   .from('profiles')
    //   .select('*')
    //   .eq('id', user.id)
    //   .single();
    
    // if (error) throw error;
    // return data as Profile;
    
    return null;
  }
};

// ============================================================
// USER SERVICES (untuk role 'user')
// ============================================================

export const userService = {
  /**
   * Create a new post (only users can create posts)
   */
  createPost: async (postData: Omit<Post, 'id' | 'uploaded_by' | 'views' | 'downloads' | 'created_at' | 'updated_at'>) => {
    // const { data: { user } } = await supabase.auth.getUser();
    // if (!user) throw new Error('User not authenticated');
    
    // // Check if user role is 'user' (not admin)
    // const { data: profile } = await supabase
    //   .from('profiles')
    //   .select('role')
    //   .eq('id', user.id)
    //   .single();
    
    // if (profile?.role !== 'user') {
    //   throw new Error('Only users can create posts. Admins cannot create posts.');
    // }
    
    // const { data, error } = await supabase
    //   .from('posts')
    //   .insert({
    //     ...postData,
    //     uploaded_by: user.id
    //   })
    //   .select()
    //   .single();
    
    // if (error) throw error;
    // return data as Post;
    
    throw new Error('Supabase not connected. Please configure Supabase connection.');
  },

  /**
   * Get all posts (public access)
   */
  getAllPosts: async (filters?: {
    faculty?: string;
    prodi?: string;
    semester?: number;
    courseCode?: string;
  }): Promise<Post[]> => {
    // let query = supabase.from('posts').select('*').order('created_at', { ascending: false });
    
    // if (filters?.faculty) {
    //   query = query.eq('faculty', filters.faculty);
    // }
    // if (filters?.prodi) {
    //   query = query.eq('prodi', filters.prodi);
    // }
    // if (filters?.semester) {
    //   query = query.eq('semester', filters.semester);
    // }
    // if (filters?.courseCode) {
    //   query = query.eq('course_code', filters.courseCode);
    // }
    
    // const { data, error } = await query;
    // if (error) throw error;
    // return data as Post[];
    
    return [];
  },

  /**
   * Get posts by current user
   */
  getMyPosts: async (): Promise<Post[]> => {
    // const { data: { user } } = await supabase.auth.getUser();
    // if (!user) throw new Error('User not authenticated');
    
    // const { data, error } = await supabase
    //   .from('posts')
    //   .select('*')
    //   .eq('uploaded_by', user.id)
    //   .order('created_at', { ascending: false });
    
    // if (error) throw error;
    // return data as Post[];
    
    return [];
  },

  /**
   * Delete own post
   */
  deleteMyPost: async (postId: string) => {
    // const { error } = await supabase
    //   .from('posts')
    //   .delete()
    //   .eq('id', postId);
    
    // if (error) throw error;
    
    throw new Error('Supabase not connected. Please configure Supabase connection.');
  },

  /**
   * Increment view count
   */
  incrementViews: async (postId: string) => {
    // const { error } = await supabase.rpc('increment_views', { post_id: postId });
    // if (error) throw error;
    
    // Note: Create this function in Supabase:
    // CREATE OR REPLACE FUNCTION increment_views(post_id UUID)
    // RETURNS VOID AS $$
    // BEGIN
    //   UPDATE posts SET views = views + 1 WHERE id = post_id;
    // END;
    // $$ LANGUAGE plpgsql;
  },

  /**
   * Increment download count
   */
  incrementDownloads: async (postId: string) => {
    // const { error } = await supabase.rpc('increment_downloads', { post_id: postId });
    // if (error) throw error;
    
    // Note: Create this function in Supabase:
    // CREATE OR REPLACE FUNCTION increment_downloads(post_id UUID)
    // RETURNS VOID AS $$
    // BEGIN
    //   UPDATE posts SET downloads = downloads + 1 WHERE id = post_id;
    // END;
    // $$ LANGUAGE plpgsql;
  }
};

// ============================================================
// ADMIN SERVICES (untuk role 'admin')
// ============================================================

export const adminService = {
  /**
   * Check if current user is admin
   */
  isAdmin: async (): Promise<boolean> => {
    // const profile = await authService.getCurrentProfile();
    // return profile?.role === 'admin';
    
    return false;
  },

  /**
   * Get all users (admin only)
   */
  getAllUsers: async (): Promise<Profile[]> => {
    // const { data, error } = await supabase
    //   .from('profiles')
    //   .select('*')
    //   .order('created_at', { ascending: false });
    
    // if (error) throw error;
    // return data as Profile[];
    
    return [];
  },

  /**
   * Get all posts (admin only - for moderation)
   */
  getAllPostsForAdmin: async (): Promise<Post[]> => {
    // const { data, error } = await supabase
    //   .from('posts')
    //   .select('*')
    //   .order('created_at', { ascending: false });
    
    // if (error) throw error;
    // return data as Post[];
    
    return [];
  },

  /**
   * Delete any post (admin only)
   */
  deletePost: async (postId: string, reason?: string) => {
    // const { data: { user } } = await supabase.auth.getUser();
    // if (!user) throw new Error('User not authenticated');
    
    // const { data: profile } = await supabase
    //   .from('profiles')
    //   .select('*')
    //   .eq('id', user.id)
    //   .single();
    
    // if (profile?.role !== 'admin') {
    //   throw new Error('Only admins can delete posts');
    // }
    
    // // Get post details before deleting
    // const { data: post } = await supabase
    //   .from('posts')
    //   .select('*')
    //   .eq('id', postId)
    //   .single();
    
    // // Delete post
    // const { error } = await supabase
    //   .from('posts')
    //   .delete()
    //   .eq('id', postId);
    
    // if (error) throw error;
    
    // // Log admin action
    // await supabase.from('admin_logs').insert({
    //   admin_id: user.id,
    //   admin_email: profile.email,
    //   action_type: 'delete_post',
    //   target_id: postId,
    //   target_email: post?.author_email,
    //   details: {
    //     post_title: post?.title,
    //     reason: reason || 'No reason provided'
    //   }
    // });
    
    throw new Error('Supabase not connected. Please configure Supabase connection.');
  },

  /**
   * Promote user to admin (admin only)
   */
  promoteUserToAdmin: async (userId: string) => {
    // const { data: { user } } = await supabase.auth.getUser();
    // if (!user) throw new Error('User not authenticated');
    
    // const { data: profile } = await supabase
    //   .from('profiles')
    //   .select('*')
    //   .eq('id', user.id)
    //   .single();
    
    // if (profile?.role !== 'admin') {
    //   throw new Error('Only admins can promote users');
    // }
    
    // // Get target user details
    // const { data: targetUser } = await supabase
    //   .from('profiles')
    //   .select('*')
    //   .eq('id', userId)
    //   .single();
    
    // if (targetUser?.role === 'admin') {
    //   throw new Error('User is already an admin');
    // }
    
    // // Promote user
    // const { error } = await supabase
    //   .from('profiles')
    //   .update({ role: 'admin' })
    //   .eq('id', userId);
    
    // if (error) throw error;
    
    // // Log admin action
    // await supabase.from('admin_logs').insert({
    //   admin_id: user.id,
    //   admin_email: profile.email,
    //   action_type: 'promote_user',
    //   target_id: userId,
    //   target_email: targetUser?.email,
    //   details: {
    //     user_name: targetUser?.full_name
    //   }
    // });
    
    throw new Error('Supabase not connected. Please configure Supabase connection.');
  },

  /**
   * Get admin logs (admin only)
   */
  getAdminLogs: async (limit: number = 50): Promise<AdminLog[]> => {
    // const { data, error } = await supabase
    //   .from('admin_logs')
    //   .select('*')
    //   .order('created_at', { ascending: false })
    //   .limit(limit);
    
    // if (error) throw error;
    // return data as AdminLog[];
    
    return [];
  }
};

// ============================================================
// FILE STORAGE SERVICES
// ============================================================

export const storageService = {
  /**
   * Upload file to Supabase Storage
   * Bucket name: 'notes-files'
   * 
   * Setup in Supabase:
   * 1. Go to Storage > Create bucket > 'notes-files'
   * 2. Set bucket to public
   * 3. Add policy to allow authenticated users to upload
   */
  uploadFile: async (file: File, folder: string = 'notes'): Promise<string> => {
    // const { data: { user } } = await supabase.auth.getUser();
    // if (!user) throw new Error('User not authenticated');
    
    // const fileExt = file.name.split('.').pop();
    // const fileName = `${user.id}/${Date.now()}.${fileExt}`;
    // const filePath = `${folder}/${fileName}`;
    
    // const { error: uploadError } = await supabase.storage
    //   .from('notes-files')
    //   .upload(filePath, file);
    
    // if (uploadError) throw uploadError;
    
    // // Get public URL
    // const { data } = supabase.storage
    //   .from('notes-files')
    //   .getPublicUrl(filePath);
    
    // return data.publicUrl;
    
    throw new Error('Supabase not connected. Please configure Supabase connection.');
  },

  /**
   * Delete file from storage
   */
  deleteFile: async (fileUrl: string) => {
    // Extract path from URL
    // const path = fileUrl.split('/notes-files/').pop();
    // if (!path) throw new Error('Invalid file URL');
    
    // const { error } = await supabase.storage
    //   .from('notes-files')
    //   .remove([path]);
    
    // if (error) throw error;
    
    throw new Error('Supabase not connected. Please configure Supabase connection.');
  }
};

// ============================================================
// TEMPORARY LOCALSTORAGE FALLBACK (for development)
// ============================================================

export const localStorageFallback = {
  /**
   * Get current user from localStorage
   */
  getCurrentUser: (): Profile | null => {
    const userData = localStorage.getItem('uninotes_user');
    if (!userData) return null;
    
    const user = JSON.parse(userData);
    return {
      id: user.email, // Using email as ID for now
      email: user.email,
      full_name: user.fullName,
      faculty: user.faculty,
      prodi: user.prodi,
      role: user.role || 'user', // Default to 'user' if not set
      profile_picture: user.profilePicture,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
  },

  /**
   * Update user role in localStorage
   */
  updateUserRole: (email: string, role: 'user' | 'admin') => {
    const savedUsers = localStorage.getItem('uninotes_users');
    if (!savedUsers) return;
    
    const users = JSON.parse(savedUsers);
    if (users[email]) {
      users[email].role = role;
      localStorage.setItem('uninotes_users', JSON.stringify(users));
      
      // Update current user if it's the same
      const currentUser = localStorage.getItem('uninotes_user');
      if (currentUser) {
        const current = JSON.parse(currentUser);
        if (current.email === email) {
          current.role = role;
          localStorage.setItem('uninotes_user', JSON.stringify(current));
        }
      }
    }
  },

  /**
   * Check if user is admin
   */
  isAdmin: (): boolean => {
    const user = localStorageFallback.getCurrentUser();
    return user?.role === 'admin';
  }
};
